# -*- coding: utf-8 -*-
"""StockAllocationModelv4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mc6N4hO-grSgmsTXXORbkRINvTvmWX7c
"""

!pip install xgboost

!pip install openpyxl

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error
from google.colab import files
import pickle
from tabulate import tabulate


# --------------------------------
# Step 1: Upload Your Excel File
# --------------------------------
uploaded = files.upload()
for filename in uploaded.keys():
    file_name = filename
    print(f"Uploaded file: {file_name}")

# --------------------------------
# Step 2: Load the Excel Data & Clean Column Names
# --------------------------------
df = pd.read_excel(file_name)

# Remove leading/trailing spaces from column names
df.columns = df.columns.str.strip()

print("Data loaded successfully:")
print(df.head())
print("\nData info:")
print(df.info())
print("Columns in df:", df.columns.tolist())

# --------------------------------
# Step 3: Fill Missing Data (No Row Drops)
# --------------------------------
# Fill missing categorical columns with "None"
cat_cols = [
    "Item Name", "Collection No", "Style Number", "Size", "Gender",
    "Category", "Sub Category", "Sillhouette", "Print",
    "Print Technique", "Color Combo", "Fabric - Top", "Fabric - Bottom",
    "Fabric - Full Garment", "Platform"
]
for col in cat_cols:
    if col in df.columns:
        df[col] = df[col].fillna("None")

# Fill missing numeric columns with 0
num_cols = ["GRN Qty", "Retail Price", "QTY SOLD", "Month", "Year"]
for col in num_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)

# --------------------------------
# Step 4: Sort and Create Lag Features
# --------------------------------
df = df.sort_values(by=["ITEM", "Platform", "Year", "Month"])

# Create lag features by grouping on (ITEM, Platform) and shifting QTY SOLD
df['lag_1'] = df.groupby(['ITEM','Platform'])['QTY SOLD'].shift(1).fillna(0)
df['lag_2'] = df.groupby(['ITEM','Platform'])['QTY SOLD'].shift(2).fillna(0)
df['lag_3'] = df.groupby(['ITEM','Platform'])['QTY SOLD'].shift(3).fillna(0)

# Create target_3m (sum of next 3 months), fill missing with 0
df['target_3m'] = (
    df.groupby(['ITEM','Platform'])['QTY SOLD'].shift(-1).fillna(0) +
    df.groupby(['ITEM','Platform'])['QTY SOLD'].shift(-2).fillna(0) +
    df.groupby(['ITEM','Platform'])['QTY SOLD'].shift(-3).fillna(0)
)

print("\nData sample after filling missing data and creating lag features:")
print(df.head(10))

# --------------------------------
# Step 5: Feature Engineering & Encoding
# --------------------------------
# One-hot encode selected categorical columns
cat_features = [
    "Sillhouette", "Print", "Print Technique", "Color Combo",
    "Fabric - Top", "Fabric - Bottom", "Fabric - Full Garment",
    "Gender", "Category", "Sub Category", "Collection No", "Style Number", "Size"
]

df_encoded = pd.get_dummies(df, columns=cat_features, drop_first=True)

# Convert "Platform", "ITEM", "Item Name" to categorical if they exist
for col in ["Platform", "ITEM", "Item Name"]:
    if col in df_encoded.columns:
        df_encoded[col] = df_encoded[col].astype('category')

# Now, remove non-predictive identifier columns
non_predictive = ["Barcode", "QTY SOLD", "target_3m", "Item Name", "Platform", "ITEM", "GRN Date"]
features = [c for c in df_encoded.columns if c not in non_predictive]

X = df_encoded[features]
y = df_encoded["target_3m"]

print("\nFeatures used in the model:")
print(features)

X.head()

y

# After your Step 5: Feature Engineering & Encoding

# Save the cleaned original data
df.to_csv("df.csv", index=False)
# Save the encoded data that was used for training the model
df_encoded.to_csv("df_encoded.csv", index=False)

print("DataFrames saved as 'df.csv' and 'df_encoded.csv'.")

# Download the files to your local machine
from google.colab import files
files.download("df.csv")
files.download("df_encoded.csv")

# --------------------------------
# Step 6: Model Training & Evaluation
# --------------------------------
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = xgb.XGBRegressor(
    objective='reg:squarederror',
    n_estimators=100,
    learning_rate=0.1,
    random_state=42,
    enable_categorical=True
)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
mae = mean_absolute_error(y_test, y_pred)
print("\nModel Evaluation:")
print(f"Test RMSE: {rmse:.2f}")
print(f"Test MAE: {mae:.2f}")

# --- Save the trained model to a pickle file ---
with open("my_xgb_model.pkl", "wb") as f:
    pickle.dump(model, f)
print("\nTrained XGBoost model has been saved to 'my_xgb_model.pkl'.")

# --------------------------------
# Step 7: Iterative Forecast for Desired Style Numbers
# --------------------------------
desired_styles = [
"C17-INWR-02",
    "C20-INWR-02",
    "C21-INWR-04",
    "C20-INWR-08",
    "C17-INWR-07",
    "C16-INWR-23",
    "C20-INWR-17",
    "C17-INWR-17",
    "C14-INWR-19",
    "C16-INWR-16",
    "C16-INWR-18",
    "C15-INWR-19",
    "C20-INWR-12",
    "C20-INWR-13",
    "C20-INWR-14",
    "C18-INWR-08",
    "C17-INWR-09"
]

# Create an item-details subset from the original df to preserve the style info
# (No duplicates dropped, so we keep everything)
df_item_details = df[[
    "ITEM", "Platform", "Collection No", "Style Number", "Size", "Item Name",
    "Category", "Sillhouette", "Fabric - Top", "Fabric - Bottom", "Fabric - Full Garment","Color Combo"
]]

# Filter to only records whose "Style Number" is in desired_styles
desired_details = df_item_details[df_item_details["Style Number"].isin(desired_styles)]

# Merge the desired details with df_encoded to get the fully encoded rows for those items
desired_encoded = pd.merge(df_encoded,
                           desired_details[["ITEM","Platform","Style Number"]],
                           on=["ITEM","Platform"],
                           how="inner")

# Get the last observation for each (ITEM, Platform) among the desired set
last_obs_desired = desired_encoded.groupby(['ITEM','Platform']).tail(1).copy()

predictions_desired = {}
for idx, row in last_obs_desired.iterrows():
    current_state = row.copy()
    monthly_preds = []
    for i in range(3):
        X_sample = current_state[features].to_frame().T
        # Match dtypes to training
        X_sample = X_sample.astype(X_train.dtypes.to_dict())
        pred = model.predict(X_sample)[0]
        monthly_preds.append(pred)
        # Update lags
        current_state['lag_3'] = current_state['lag_2']
        current_state['lag_2'] = current_state['lag_1']
        current_state['lag_1'] = pred
    predictions_desired[(row['ITEM'], row['Platform'])] = monthly_preds

results_desired = []
for (item, platform), preds in predictions_desired.items():
    results_desired.append({
        "ITEM": item,
        "Platform": platform,
        "Feb_pred": preds[0],
        "Mar_pred": preds[1],
        "Apr_pred": preds[2],
        "Total_3m": sum(preds)
    })
results_df_desired = pd.DataFrame(results_desired)
print("\nForecast Results for Desired Items (first 10 rows):")
print(results_df_desired.head(10))

# Merge forecast results with desired details to get style info
detailed_desired = pd.merge(
    results_df_desired,
    desired_details,
    on=["ITEM","Platform"],
    how="left"
)
# -------------------------------
# Round and clip the prediction columns
# -------------------------------
for col in ["Feb_pred", "Mar_pred", "Apr_pred", "Total_3m"]:
    if col in detailed_desired.columns:
        # Round to the nearest integer and clip negative values to 0
        detailed_desired[col] = detailed_desired[col].round(0).clip(lower=0).astype(int)

print("\nDetailed Forecast for Desired Style Numbers (first 10 rows):")
print(detailed_desired[[
    "ITEM", "Item Name", "Collection No", "Style Number", "Size",
    "Sillhouette", "Fabric - Top", "Fabric - Bottom", "Fabric - Full Garment",
    "Feb_pred", "Mar_pred", "Apr_pred", "Total_3m"
]].head(10))

# --------------------------------
# Step 8: Aggregate & Visualize by Style Number and Color Combo
# --------------------------------
# Group the detailed forecast results by "Style Number" and "Color Combo"
style_sums_desired = detailed_desired.groupby(["Style Number", "Color Combo"], as_index=False).agg({
    "Feb_pred": "sum",
    "Mar_pred": "sum",
    "Apr_pred": "sum"
})
style_sums_desired["Total_3m"] = (style_sums_desired["Feb_pred"] +
                                   style_sums_desired["Mar_pred"] +
                                   style_sums_desired["Apr_pred"])

# Round all forecast values to the nearest whole number and clip negatives to 0
for col in ["Feb_pred", "Mar_pred", "Apr_pred", "Total_3m"]:
    style_sums_desired[col] = style_sums_desired[col].round(0).clip(lower=0).astype(int)

print("\nAggregated Forecast by Desired Style Number and Color Combo:")
print(style_sums_desired)

# Create a label combining Style Number and Color Combo for visualization
style_sums_desired["Label"] = style_sums_desired["Style Number"] + " (" + style_sums_desired["Color Combo"] + ")"

# Stacked Bar Chart for these style numbers with color info
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(len(style_sums_desired))
width = 0.8  # full width for each bar

plt.figure(figsize=(12,6))
bar1 = plt.bar(x, style_sums_desired['Feb_pred'], width, label='February')
bar2 = plt.bar(x, style_sums_desired['Mar_pred'], width,
               bottom=style_sums_desired['Feb_pred'], label='March')
bar3 = plt.bar(x, style_sums_desired['Apr_pred'], width,
               bottom=style_sums_desired['Feb_pred']+style_sums_desired['Mar_pred'], label='April')

plt.xlabel("Style Number (Color Combo)")
plt.ylabel("Predicted Sales (Next 3 Months)")
plt.title("Aggregated Forecast by Style Number and Color Combo (Feb, Mar, Apr)")
plt.xticks(x, style_sums_desired['Label'], rotation=45)
plt.legend()
plt.tight_layout()

# Annotate each segment with its numeric value (as integers)
for i, (feb, mar, apr, total) in enumerate(zip(style_sums_desired['Feb_pred'],
                                               style_sums_desired['Mar_pred'],
                                               style_sums_desired['Apr_pred'],
                                               style_sums_desired['Total_3m'])):
    plt.text(x[i], feb/2, f"{feb}", ha='center', va='center', color='white', fontsize=9)
    plt.text(x[i], feb + mar/2, f"{mar}", ha='center', va='center', color='white', fontsize=9)
    plt.text(x[i], feb + mar + apr/2, f"{apr}", ha='center', va='center', color='white', fontsize=9)
    plt.text(x[i], total + 0.05*total, f"{total}", ha='center', va='bottom', color='black', fontsize=9)

plt.show()

# --------------------------------
# Step 9: Save Detailed Forecast for Desired Items
# --------------------------------
output_file = "Desired_Style_Forecast_NoDrops_MEN.xlsx"
detailed_desired.to_excel(output_file, index=False)
files.download(output_file)

print(df.columns.tolist())

import matplotlib.pyplot as plt

# Define the list of desired style numbers you want to plot
desired_styles = ["C20-INWR-15","C20-INWR-16","C20-INWR-17"]

plt.figure(figsize=(12, 6))

for style in desired_styles:
    # Filter the DataFrame for the current style
    temp = df[df["Style Number"] == style].copy()

    # Group by Year and Month to sum up QTY SOLD
    trend = temp.groupby(["Year", "Month"], as_index=False)["QTY SOLD"].sum()

    # Create a Time label, for instance "2024-3" or "2024-March"
    # If your "Month" is an integer (e.g. 3 for March), convert to str:
    #     trend["Time"] = trend["Year"].astype(str) + "-" + trend["Month"].astype(str)
    # If your "Month" is a string month name, you can just do:
    #     trend["Time"] = trend["Year"].astype(str) + "-" + trend["Month"]
    # Choose the approach that matches your data:

    trend["Time"] = trend["Year"].astype(str) + "-" + trend["Month"].astype(str)

    # Plot the line for this style
    plt.plot(trend["Time"], trend["QTY SOLD"], marker="o", label=f"Style {style}")

plt.xlabel("Time (Year-Month)")
plt.ylabel("Total QTY SOLD")
plt.title("Historical Sales Trend for Desired Styles")
plt.xticks(rotation=45, ha='right')  # rotate x-axis labels for clarity
plt.legend()
plt.tight_layout()
plt.show()



"""```
# This is formatted as code # ------------------------------------------------------------------------------
# EXAMPLE: Creating a Non-Technical "Sales & Inventory" Table
# ------------------------------------------------------------------------------

# 1) Suppose you have a final DataFrame "detailed_desired" (from your forecast),
#    which includes columns like:
#      - "ITEM" or "Style Number"
#      - "Platform" (store location or channel)
#      - "Category"
#      - "Size"
#      - "Color Combo"
#      - "GRN Qty"
#      - "QTY SOLD" (historical)
#      - "Feb_pred", "Mar_pred", "Apr_pred" (predicted monthly sales) or "Total_3m"

# For demonstration, let's call your final forecast DataFrame "final_df".
# Adjust the variable names/column references to match your code.

final_df = detailed_desired.copy()  # rename or adapt as needed

# 2) Define a function to estimate “current stock” from your data
#    e.g., Current Stock = GRN Qty - QTY SOLD (if that’s how you track on-hand).
#    If you track "lag_1" or something else, adapt accordingly.

#final_df["Current_Stock"] = final_df["GRN Qty"] - final_df["QTY SOLD"]

# 3) Suppose you want to pick ONE predicted month as "Monthly Sales" (like "Feb_pred")
#    or you could sum "Feb_pred"+"Mar_pred"+"Apr_pred" and call it “3-month sales”.
#    Here, let's assume "Monthly Sales" is the sum of next 3 months / 3 for an average.
#    Adapt as needed.

final_df["Monthly_Sales"] = (final_df["Feb_pred"] + final_df["Mar_pred"] + final_df["Apr_pred"]) / 3

# 4) Compute "Avg. Weekly Sales" as monthly sales / 4
final_df["Avg_Weekly_Sales"] = final_df["Monthly_Sales"] / 4

# 5) Simple “Stockout Risk” logic:
#    - If Current Stock < Monthly Sales => "High"
#    - Else if Current Stock < 2 * Monthly Sales => "Medium"
#    - Else => "Low"

conditions = [
    final_df["Current_Stock"] < final_df["Monthly_Sales"],
    final_df["Current_Stock"] < 2 * final_df["Monthly_Sales"]
]
choices = ["High", "Medium"]
final_df["Stockout_Risk"] = np.select(conditions, choices, default="Low")

# 6) Simple “Reorder Suggestion” logic:
#    - If Stockout Risk == "High" => "Yes (Order 100)"
#    - If Stockout Risk == "Medium" => "Yes (Order 50)"
#    - Else => "No"

def reorder_logic(risk):
    if risk == "High":
        return "Yes (Order 100)"
    elif risk == "Medium":
        return "Yes (Order 50)"
    else:
        return "No"

final_df["Reorder_Suggestion"] = final_df["Stockout_Risk"].apply(reorder_logic)

# 7) Create a final, user-friendly DataFrame with columns you want to show
#    e.g., “Style Code”, “Category”, “Size”, “Color”, “Store Location”,
#          “Current Stock”, “Monthly Sales”, “Avg. Weekly Sales”, “Stockout Risk”, “Reorder Suggestion”
#    Adjust column references to your actual column names.

sales_inventory_table = final_df[[
     "Style Number",            # or "ITEM"
    "Category",
    "Size",
    "Color Combo",
    "Platform",                # store location or channel
    "GRN Qty",                 # Add "GRN Qty" here
    "QTY SOLD",                # Add "QTY SOLD" here
    "Current_Stock",
    "Monthly_Sales",
    "Avg_Weekly_Sales",
    "Stockout_Risk",
    "Reorder_Suggestion"
]].copy()

# 8) Round numeric columns for a neat display
numeric_cols = ["Current_Stock", "Monthly_Sales", "Avg_Weekly_Sales"]
for col in numeric_cols:
    sales_inventory_table[col] = sales_inventory_table[col].round(0).clip(lower=0).astype(int)

# 9) Rename columns to more user-friendly names if desired
sales_inventory_table.rename(columns={
    "Style Number": "Style Code",
    "Color Combo": "Color",
    "Platform": "Store Location",
    "Current_Stock": "Current Stock",
    "Monthly_Sales": "Monthly Sales",
    "Avg_Weekly_Sales": "Avg. Weekly Sales",
    "Stockout_Risk": "Stockout Risk",
    "Reorder_Suggestion": "Reorder Suggestion"
}, inplace=True)

# 10) Display the final table in a non-technical, easy-to-read format
print("\nSales & Inventory Data Table (Raw Data)\n")
print(tabulate(sales_inventory_table, headers="keys", tablefmt="psql"))

# If you want to export to Excel:
# sales_inventory_table.to_excel("Sales_Inventory_Table.xlsx", index=False)
```

```
# This is formatted as code
```# 1. Filter the data for desired styles
filtered_df = df[df["Style Number"].isin(desired_styles)]

# 2. Group the filtered data by "Style Number"
#    Summing "GRN Qty" and "QTY SOLD" for each style.
grouped = filtered_df.groupby("Style Number", as_index=False).agg({
    "GRN Qty": "sum",
    "QTY SOLD": "sum"
})

# 3. Rename columns to match your final table
grouped.rename(columns={
    "GRN Qty": "Sum of GRN QTY",
    "QTY SOLD": "Sum of Sales"
}, inplace=True)

# 4. Calculate "Sum of Total Stock in hand" as GRN minus total sales
grouped["Sum of Total Stock in hand"] = grouped["Sum of GRN QTY"] - grouped["Sum of Sales"]

# 5. Compute sell-through (handle divide-by-zero by labeling it "N/A")
# Instead of directly converting to int, handle inf and NaN separately
grouped["Sell through"] = (grouped["Sum of Sales"] / grouped["Sum of GRN QTY"] * 100).round(0)
grouped["Sell through"] = grouped["Sell through"].fillna("N/A")  # Replace NaN with "N/A"
grouped["Sell through"] = grouped["Sell through"].replace(np.inf, "N/A")  # Replace inf with "N/A"
grouped.loc[grouped["Sell through"] != "N/A", "Sell through"] = grouped.loc[grouped["Sell through"] != "N/A", "Sell through"].astype(int).astype(str) + "%"

# 6. Reorder columns to match your example
final_table = grouped[[
    "Style Number",
    "Sum of Total Stock in hand",
    "Sum of GRN QTY",
    "Sum of Sales",
    "Sell through"
]]

# 7. Display the table
print("\nPrevious Collection Style No and Sell Through:")
print(tabulate(final_table, headers='keys', tablefmt='psql')) # Format the table
"""